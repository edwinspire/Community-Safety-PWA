const { BOT_TOKEN } = process.env;
const crypto = require("crypto");
//console.log('BOT_TOKEN: ', BOT_TOKEN);

const EventEmitter = require('events');
const TelegrafOrg = require('telegraf')
//const Extra = require('telegraf/extra')
const Markup = require('telegraf/markup')
const ServerRoot = require("@edwinspire/express-server/GetServerRoot");
const { FetchDataNode } = require("@edwinspire/fetch/FetchDataNode");
const { EVENTS } = require("sax");
const textEmergency = "ðŸš¨ EMERGENCIA";
const textwarning = "âš  ADVERTENCIA";
const textTest = "ðŸ”ˆ PRUEBA";
const textTurnoff = "ðŸ”‡ APAGAR";


module.exports.Telegraf = class Telegraf extends EventEmitter {
    constructor() {
        super()

        this.FDataNode = new FetchDataNode();

        this.bot = new TelegrafOrg(BOT_TOKEN);

        this.bot.command('getid', (ctx) => {
            //console.log('consulta grupo >>> ', ctx.update.message.chat.id);
            ctx.reply('idgroup: ' + Telegraf.getidgroup(ctx.update.message.chat.id))
        });


        this.bot.command('register', async (ctx) => {
            ctx.reply('Un momento por favor. Se estÃ¡ registrando el grupo...');
            try {
                let res = await this.FDataNode.post(
                    ServerRoot() + "/pgapi/OpenCommunitySecurity/Account",
                    ctx.update.message
                );
                let data_res = await res.json();

                ctx.reply(
                    data_res.account_name +
                    " se encuentra registrado. ID: " +
                    data_res.uniqueid
                );
            } catch (error) {
                console.log(error);
                ctx.reply("OcurriÃ³ un error, no se pudo registrar");
            }
        });




        this.bot.command('/start', ({ reply }) => {
            return reply('Seleccione una opciÃ³n', Markup
                .keyboard([
                    [textEmergency],
                    [textwarning],
                    [textTest, textTurnoff]
                ])
                .oneTime()
                .resize()
                .extra()
            )
        })

        this.bot.hears(textEmergency, async (ctx) => {
            let message = "";
            try {
                let reevent = await Telegraf.SendEvent(ctx, 'ocs001');
                message = reevent.message;
            } catch (error) {
                message = 'OcurriÃ³ un error: ' + JSON.stringify(error)
            }
            ctx.reply(message);
        })
        this.bot.hears(textwarning, async (ctx) => {
            let message = "";
            try {
                let reevent = await Telegraf.SendEvent(ctx, 'ocs003');
                message = reevent.message;
            } catch (error) {
                message = 'OcurriÃ³ un error: ' + JSON.stringify(error)
            }
            ctx.reply(message);
        })
        this.bot.hears(textTest, async (ctx) => {
            let message = "";
            try {
                let reevent = await Telegraf.SendEvent(ctx, 'ocs004');
                message = reevent.message;
            } catch (error) {
                message = 'OcurriÃ³ un error: ' + JSON.stringify(error)
            }
            ctx.reply(message);
        })
        this.bot.hears(textTurnoff, async (ctx) => {
            //console.log('Pulsa APAGAR');
            let message = "";
            try {
                let reevent = await Telegraf.SendEvent(ctx, 'ocs002');
                message = reevent.message;
            } catch (error) {
                message = 'OcurriÃ³ un error: ' + JSON.stringify(error)
                console.log(error);
            }
            ctx.reply(message);
        });




    }



    static getidgroup(idgroup) {
        let c = crypto
            .createHash("md5")
            .update(JSON.stringify(idgroup))
            .digest("hex");
        //console.log('MD5 de ', idgroup, JSON.stringify(idgroup), c);
        return c;
    }

    launch() {
        //CreateSocketIONameSpace(socketioInstance)
        this.bot.launch();
    }

    static async SendEventOCS(data) {
        console.log('SendEventOCS', data);
        try {
            //console.log(data);
            let FDataNodeFetch = new FetchDataNode();
            let res = await FDataNodeFetch.post(
                ServerRoot() + "/pgapi/OpenCommunitySecurity/event",
                data
            );
            let data_res = await res.json();
            //console.log(data_res);
            if (Array.isArray(data_res) && data_res.length > 0) {
                return data_res[0];
            } else {
                console.log(data_res);
                return data_res;
            }

        } catch (error) {
            console.log(error);
            return error;
        }
    }


    static async SendEvent(ctx, eventcode) {
        console.log('SendEvent', eventcode);
        try {
            let data = { idgroup: Telegraf.getidgroup(ctx.message.chat.id), message: ctx.message, eventcode: eventcode };
            return await Telegraf.SendEventOCS(data);
            //ctx.reply(resp.message)
        } catch (error) {
            console.log(error);
            return error;
        }
    }

    static async getEventById(idevent) {
        try {
            let FDataNodeFetch = new FetchDataNode();
            let res = await FDataNodeFetch.get(
                ServerRoot() + "/pgapi/OpenCommunitySecurity/event",
                { idevent: idevent }
            );

            let data_res = await res.json();

            if (Array.isArray(data_res) && data_res.length > 0) {
                return data_res[0];
            } else {
                console.log('OJO ==>>>> ', data_res);
                return data_res;
            }

        } catch (error) {
            console.log('getEventById', error);
            return error;
        }
    }

    sendMessageToGroup(event) {
        //console.log('>>>>>>> event.idgroup', event);
        if (event && event.idevent > 0) {
            if (typeof event.identification !== 'undefined') {
                this.bot.telegram.sendMessage(event.identification, event.label + ' ' + event.details.message.description);
            }
        } else {
            console.trace('sendMessageToGroup evento no vÃ¡lido', event);
        }
    }

    async ProcessPgNotification(socketio, pgNotifyEvent) {

console.log(pgNotifyEvent, pgNotifyEvent.channel);

        if (pgNotifyEvent && pgNotifyEvent.channel) {
            try {
                switch (pgNotifyEvent.channel) {
                    case 'events.data':
                        let payloadNotify = JSON.parse(pgNotifyEvent.payload);
                        if (payloadNotify && payloadNotify.idevent && payloadNotify.idevent > 0) {
                            let event = await community_safety.getEventById(payloadNotify.idevent);
                            community_safety.EmitEventToNameSpace(socketio, event);
                            this.sendMessageToGroup(event);
                        } else {
                            console.error("pgNotifyProcess - El evento no es vÃ¡lido", pgNotifyEvent);
                        }
                        break;
                }
            } catch (error) {
                console.error('ProcessPgNotification 2', pgNotifyEvent);
            }
        } else {
            console.error('ProcessPgNotification 1', pgNotifyEvent);
        }
    }

    static EmitEventToNameSpace(socketioInstance, event) {
        let namespace = "/appocs";

        if (event && typeof event.identification !== 'undefined') {
            //3) Obtener el namespace del evento
            namespace += '-' + Telegraf.getidgroup(Number(event.identification));
            //console.log('====>>>>', namespace, event.ideventtype, event.code);
            //4) Emitir el evento al socketio
            socketioInstance.of(namespace).emit(event.code, {});
            console.log('EmitEventToNameSpace emite ' + event.code);
        } else {
            console.log('EmitEventToNameSpace Evento no vÃ¡lido', event);
        }
    }

    static CreateSocketIONameSpace(socketioInstance) {
        // Crea el namespace de forma dinamica
        let namespace_appocs = socketioInstance.of(/\/appocs-(.+)/g);

        namespace_appocs.on("connection", (socket) => {
            console.log("NAMESPACE DINAMICO");

            socket.use((packet, next) => {
                switch (packet[1]) {
                    case "ocsdevconnected":
                        Telegraf.SendEventOCS({ idgroup: packet[0].idgroup, message: packet[0], eventcode: 'ocsdevconnected' });
                        break;
                    case "device":
                        //let data = { idgroup: packet[0].idgroup, message: 'Device', eventcode: 'device' };
                        Telegraf.SendEventOCS({ idgroup: packet[0].idgroup, message: packet[0], eventcode: 'device' });
                        break;
                }

                next();
            });

        });

    }

}


/*
/////////////////////////////////
bot.command('/start', ({ reply }) => {
    return reply('Seleccione una opciÃ³n', Markup
        .keyboard([
            ['EMERGENCIA'],
            ['ADVERTENCIA'],
            ['PROBAR', 'APAGAR']
        ])
        .oneTime()
        .resize()
        .extra()
    )
})

bot.hears('EMERGENCIA', ctx => ctx.reply('Alarma de emergencia!'))
bot.hears('ADVERTENCIA', ctx => ctx.reply('Alarma de adventencia!'))
bot.hears('PROBAR', ctx => ctx.reply('Prueba de dispositivos'))
bot.hears('APAGAR', ctx => ctx.reply('Apagar alarma'))





bot.command('alarmas', (ctx) => {

    console.dir('alarmas >>> ', ctx.update.message.chat);

    if (ctx.update.message.chat.type == "private") {

        return ctx.reply('Botones especiales', Extra.markup((markup) => {
            return markup.resize()
                .keyboard([
                    markup.contactRequestButton('Enviar contacto'),
                    markup.locationRequestButton('Activar Alarma')
                ])
        }))
    } else {
        ctx.telegram.sendMessage(ctx.message.chat.id, `OpciÃ³n habilitada solo en chats privados`)
    }

})


bot.command('dispositivos', (ctx) => {

    console.dir('dispositivos >>> ', ctx.update);

    ctx.telegram.sendMessage(ctx.message.chat.id,
        `/ListarDispositivo: Listar dispositivos
/AgregarDispositivo : Agrega
/EliminarDispositivo : Elimina
`
    )


})




bot.on('message', (ctx) => {
    console.log('message >>> ', ctx.message);


    if (ctx.message.new_chat_members && ctx.message.new_chat_members.length > 0) {


        ctx.message.new_chat_members.forEach(element => {
            console.log(element);

            if (element.is_bot) {

                ctx.telegram.sendMessage(ctx.message.from.id, ' Has registrado un nuevo bot en el Grupo ');
                ctx.telegram.sendMessage(ctx.message.chat.id, ` ${ctx.message.from.username} ha registrado un nuevo bot en el Grupo `);
                ctx.telegram.sendMessage(element.id, '/id');

            }

        });

    }


})
*/

