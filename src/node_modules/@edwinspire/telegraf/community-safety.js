const { BOT_TOKEN } = process.env;
const crypto = require("crypto");
//console.log('BOT_TOKEN: ', BOT_TOKEN);

const EventEmitter = require('events');
const TelegrafOrg = require('telegraf')
//const Extra = require('telegraf/extra')
const Markup = require('telegraf/markup')
const ServerRoot = require("@edwinspire/express-server/GetServerRoot");
const { FetchDataNode } = require("@edwinspire/fetch/FetchDataNode");
const textEmergency = "ðŸš¨ EMERGENCIA";
const textwarning = "âš  ADVERTENCIA";
const textTest = "ðŸ”ˆ PRUEBA";
const textTurnoff = "ðŸ”‡ APAGAR";


module.exports.Telegraf = class Telegraf extends EventEmitter {
    constructor() {
        super()

        this.FDataNode = new FetchDataNode();

        this.bot = new TelegrafOrg(BOT_TOKEN);

        this.bot.command('getid', (ctx) => {
            console.log('consulta grupo >>> ', ctx.update.message.chat.id);
            ctx.reply('idgroup: ' + Telegraf.getidgroup(ctx.update.message.chat.id))
        });


        this.bot.command('register', async (ctx) => {
            ctx.reply('Un momento por favor. Se estÃ¡ registrando el grupo...');
            try {
                let res = await this.FDataNode.post(
                    ServerRoot() + "/pgapi/OpenCommunitySecurity/Account",
                    ctx.update.message
                );
                let data_res = await res.json();
                console.log(data_res);

                ctx.reply(
                    data_res.account_name +
                    " se encuentra registrado. ID: " +
                    data_res.uniqueid
                );
            } catch (error) {
                console.log(error);
                ctx.reply("OcurriÃ³ un error, no se pudo registrar");
            }
        });




        this.bot.command('/start', ({ reply }) => {
            return reply('Seleccione una opciÃ³n', Markup
                .keyboard([
                    [textEmergency],
                    [textwarning],
                    [textTest, textTurnoff]
                ])
                .oneTime()
                .resize()
                .extra()
            )
        })

        this.bot.hears(textEmergency, async (ctx) => {
            let message = "";
            try {
                let reevent = await Telegraf.SendEvent(ctx, 'ocs001');
                message = reevent.message;
            } catch (error) {
                message = 'OcurriÃ³ un error: ' + JSON.stringify(error)
            }
            ctx.reply(message);
        })
        this.bot.hears(textwarning, async (ctx) => {
            let message = "";
            try {
                let reevent = await Telegraf.SendEvent(ctx, 'ocs003');
                message = reevent.message;
            } catch (error) {
                message = 'OcurriÃ³ un error: ' + JSON.stringify(error)
            }
            ctx.reply(message);
        })
        this.bot.hears(textTest, async (ctx) => {
            let message = "";
            try {
                let reevent = await Telegraf.SendEvent(ctx, 'ocs004');
                message = reevent.message;
            } catch (error) {
                message = 'OcurriÃ³ un error: ' + JSON.stringify(error)
            }
            ctx.reply(message);
        })
        this.bot.hears(textTurnoff, async (ctx) => {
            //console.log('Pulsa APAGAR');
            let message = "";
            try {
                let reevent = await Telegraf.SendEvent(ctx, 'ocs002');
                message = reevent.message;
            } catch (error) {
                message = 'OcurriÃ³ un error: ' + JSON.stringify(error)
                console.log(error);
            }
            ctx.reply(message);
        });




    }



    static getidgroup(idgroup) {
        let c = crypto
            .createHash("md5")
            .update(JSON.stringify(idgroup))
            .digest("hex");
        console.log('MD5 de ', idgroup, JSON.stringify(idgroup), c);
        return c;
    }

    launch() {

        this.bot.launch();
    }

    static async SendEvent(ctx, eventcode) {


        try {
            let data = { idgroup: Telegraf.getidgroup(ctx.message.chat.id), message: ctx.message, eventcode: eventcode };

            console.log(data);
            let FDataNodeFetch = new FetchDataNode();
            let res = await FDataNodeFetch.post(
                ServerRoot() + "/pgapi/OpenCommunitySecurity/event",
                data
            );
            let data_res = await res.json();
            console.log(data_res);
            if (data_res.length > 0) {
                return data_res[0];
            } else {
                return data_res;
            }

        } catch (error) {
            console.log(error);
            return error;
        }
    }

    static async getEventById(idevent) {
        try {
            let FDataNodeFetch = new FetchDataNode();
            let res = await FDataNodeFetch.get(
                ServerRoot() + "/pgapi/OpenCommunitySecurity/event",
                { idevent: idevent }
            );
            let data_res = await res.json();

            if (data_res.length > 0) {
                return data_res[0];
            } else {
                return data_res;
            }

        } catch (error) {
            console.log(error);
            return error;
        }
    }

    static async EmitEventToNameSpace(socketioInstance, pgNotify) {
        let namespace = "appocs";
        //console.log(pgNotify.payload);
        //1) identificar el canal de notificaciÃ³n
        if (pgNotify.channel == 'events.data') {
            //2) Obtener los datos del evento
            let payloadNotify = JSON.parse(pgNotify.payload);
            let event = await Telegraf.getEventById(payloadNotify.idevent);
            if (typeof event.idgroup !== 'undefined') {
                //3) Obtener el namespace del evento
                namespace = "/appocs-" + Telegraf.getidgroup(Number(event.idgroup));
                console.log(namespace, event.ideventtype);
                //4) Emitir el evento al socketio
                socketioInstance.of(namespace).emit(event.code, {});
            }

        }


    }

    static CreateSocketIONameSapce(socketioInstance) {
        // Crea el namespace de forma dinamica
        let namespace_appocs = socketioInstance.of(/\/appocs-(.+)/g);

        namespace_appocs.on("connection", (socket) => {
            console.log("NAMESPACE DINAMICO");
            socket.emit("getdevice", { action: "getdevice" });

            socket.on("device", (socket1) => {
                //socket.emit("appocs", { action: "getid" });
                console.log(
                    "+++++++++>>>>> device ",
                    socket1
                );
            });
        });

    }

}


/*
/////////////////////////////////
bot.command('/start', ({ reply }) => {
    return reply('Seleccione una opciÃ³n', Markup
        .keyboard([
            ['EMERGENCIA'],
            ['ADVERTENCIA'],
            ['PROBAR', 'APAGAR']
        ])
        .oneTime()
        .resize()
        .extra()
    )
})

bot.hears('EMERGENCIA', ctx => ctx.reply('Alarma de emergencia!'))
bot.hears('ADVERTENCIA', ctx => ctx.reply('Alarma de adventencia!'))
bot.hears('PROBAR', ctx => ctx.reply('Prueba de dispositivos'))
bot.hears('APAGAR', ctx => ctx.reply('Apagar alarma'))





bot.command('alarmas', (ctx) => {

    console.dir('alarmas >>> ', ctx.update.message.chat);

    if (ctx.update.message.chat.type == "private") {

        return ctx.reply('Botones especiales', Extra.markup((markup) => {
            return markup.resize()
                .keyboard([
                    markup.contactRequestButton('Enviar contacto'),
                    markup.locationRequestButton('Activar Alarma')
                ])
        }))
    } else {
        ctx.telegram.sendMessage(ctx.message.chat.id, `OpciÃ³n habilitada solo en chats privados`)
    }

})


bot.command('dispositivos', (ctx) => {

    console.dir('dispositivos >>> ', ctx.update);

    ctx.telegram.sendMessage(ctx.message.chat.id,
        `/ListarDispositivo: Listar dispositivos
/AgregarDispositivo : Agrega
/EliminarDispositivo : Elimina
`
    )


})




bot.on('message', (ctx) => {
    console.log('message >>> ', ctx.message);


    if (ctx.message.new_chat_members && ctx.message.new_chat_members.length > 0) {


        ctx.message.new_chat_members.forEach(element => {
            console.log(element);

            if (element.is_bot) {

                ctx.telegram.sendMessage(ctx.message.from.id, ' Has registrado un nuevo bot en el Grupo ');
                ctx.telegram.sendMessage(ctx.message.chat.id, ` ${ctx.message.from.username} ha registrado un nuevo bot en el Grupo `);
                ctx.telegram.sendMessage(element.id, '/id');

            }

        });

    }


})
*/

