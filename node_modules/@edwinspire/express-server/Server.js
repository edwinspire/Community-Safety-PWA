const { PORT, NODE_ENV, TOKEN_ENCRYPT } = process.env;
const dev = NODE_ENV === "development";
import * as sapper from "@sapper/server";
import sirv from "sirv";
import compression from "compression";
import pgAccessPoint from "@edwinspire/express-pgapi/pgAccessPoint";
import GeneralRoutes from "@express-routes/routes";
const EventEmitter = require('events');
const express = require("express");
const session = require("express-session");
const morgan = require("morgan");
const cookieParser = require("cookie-parser");
const SendEvent = require("@edwinspire/oms/SendEvent");
const passport = require("passport");
const { pgListen } = require("@edwinspire/express-pgapi/pgListen");
const { SocketIO } = require("@edwinspire/express-server/SocketIO");
const { Token } = require("@edwinspire/tokens/Tokendb");

export class Server extends EventEmitter {
  constructor({credentials, cluster, listen_notification_list}) {
    super();
    if(listen_notification_list && listen_notification_list.length > 0){
      new pgListen(listen_notification_list).on('notification', (notify) => {
        this.emit('pgNotify', notify);
      });
    }

    this.token = new Token();

    this.socketio = () => { };

    this.app = express(); //instancia de express
    this.app.use(morgan("dev"));
    this.app.use(cookieParser(TOKEN_ENCRYPT));
    this.app.use(express.json({ strict: false, limit: 100000000 })); //-- Limit 100M
    this.app.use(express.urlencoded({limit: '100mb', extended: true }));

    this.app.use(
      session({
        secret: TOKEN_ENCRYPT,
        resave: true,
        saveUninitialized: true,
        cookie: {
          maxAge: 2 * 60 * 60 * 1000, // 1 hour
          httpOnly: true,
          //secure: false, // Uncomment this line to enforce HTTPS protocol.
          sameSite: true,
        },
      })
    );
    this.app.use(passport.initialize());
    require("@edwinspire/express-pgapi/Passport");

    this.app.use(pgAccessPoint);
    this.app.use(GeneralRoutes);

    this.app.use(
      compression({ threshold: 0 }),
      sirv("static", { dev }),
      sapper.middleware({
        // customize the session
        session: (req, res) => {
          let userT;
          try {
            userT = this.token.getUserFromRequest(req);
          } catch (error) {
            console.trace(error);
          }
          return { user: userT };
        },
      })
    );

    let httpServer;

    if (!process.env.LOCAL_SERVER) {
      httpServer = require("http").createServer(this.app);
      console.log("Usando HTTP");
    } else {
      httpServer = require("https").createServer(credentials, this.app);
      console.log("Usando HTTPS");
    }


    if (httpServer) {

      this.socketio = SocketIO(httpServer);

      httpServer.on("error", (e) => {
        console.trace(e);
      });

      httpServer.listen(PORT, () => {
        if(cluster){
          console.log("App listening on port " + PORT + " " + cluster.worker.id);
        }else{
          console.log("App listening on port " + PORT );
        }
      });
    }


  }

get clients(){
  return this.socketio.sockets.sockets;
}

}



//export function Server(credentials, cluster) {


/**
 *
 let pl = new pgListen("test");
    pl.on("notification", (e) => {
      console.log("CONNECTION HECHA");
      socket.emit(
        "chat",
        "Se ha recibido una alarma, as√≠ que hay que disparar la sirena"
      );
    });
 *
 */


 // return true;
//}

